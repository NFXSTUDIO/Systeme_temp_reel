Index: process.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import heapq\r\nfrom collections import deque\r\n\r\nclass Process:\r\n    def __init__(self, pid, arrival_time, burst_time, period=None, deadline=None):\r\n        self.pid = pid                      # id of the process\r\n        self.arrival_time = arrival_time    # time of the arrival\r\n        self.burst_time = burst_time        # execution time\r\n        self.remaining_time = burst_time    # time left before the end of execution\r\n        self.waiting_time = 0               # waiting time\r\n        self.turnaround_time = 0            # time between the arrival and the end of the execution\r\n        self.period = period\r\n        self.deadline = deadline\r\n\r\ndef fcfs_scheduling(processes):\r\n    processes.sort(key=lambda x: x.arrival_time)  # sort per arrival\r\n    time = 0\r\n    results = []\r\n    total_waiting_time = 0\r\n    start_time = 0\r\n    \r\n    processes.sort(key=lambda x: x.arrival_time)\r\n    \r\n    for process in processes:\r\n        if time >= process.arrival_time:\r\n            start_time = time\r\n            while process.remaining_time > 0:\r\n                time += 1\r\n                process.remaining_time -= 1\r\n            if process.remaining_time == 0:\r\n                process.waiting_time = time - process.arrival_time\r\n                process.turnaround_time = process.waiting_time + process.burst_time\r\n                total_waiting_time += process.waiting_time\r\n                results.append((process.pid, start_time, time))\r\n    \r\n    performances = total_waiting_time / len(processes)\r\n    return results, time, performances\r\n\r\ndef sjn_scheduling(processes):\r\n    processes.sort(key=lambda x: x.arrival_time)\r\n    ready_queue = []\r\n    time = 0\r\n    results = []\r\n    index = 0\r\n    total_waiting_time = 0\r\n\r\n    while index < len(processes) or ready_queue:\r\n        while index < len(processes) and processes[index].arrival_time <= time:\r\n            heapq.heappush(ready_queue, (processes[index].burst_time, processes[index]))\r\n            index += 1\r\n\r\n        if ready_queue:\r\n            _, process = heapq.heappop(ready_queue)\r\n            process.waiting_time = time - process.arrival_time\r\n            process.turnaround_time = process.waiting_time + process.burst_time\r\n            total_waiting_time += process.waiting_time\r\n            results.append((process.pid, time, time + process.burst_time))\r\n            time += process.burst_time\r\n        else:\r\n            time = processes[index].arrival_time\r\n\r\n    performances = total_waiting_time / len(processes)\r\n    return results, time, performances\r\n\r\ndef rr_scheduling(processes, quantum=4):\r\n    time = 0\r\n    results = []\r\n    ready_queue = deque()\r\n    total_waiting_time = 0\r\n    completed = 0\r\n    n = len(processes)\r\n\r\n    for p in processes:\r\n        p.remaining_time = p.burst_time\r\n\r\n    processes.sort(key=lambda x: x.arrival_time)\r\n    index = 0\r\n\r\n    while completed != n:\r\n        while index < n and processes[index].arrival_time <= time:\r\n            ready_queue.append(processes[index])\r\n            index += 1\r\n\r\n        if not ready_queue:\r\n            time += 1\r\n            continue\r\n\r\n        process = ready_queue.popleft()\r\n        start_time = time\r\n\r\n        if process.remaining_time <= quantum:\r\n            time += process.remaining_time\r\n            process.remaining_time = 0\r\n            process.waiting_time = time - process.arrival_time - process.burst_time\r\n            process.turnaround_time = time - process.arrival_time\r\n            total_waiting_time += process.waiting_time\r\n            results.append((process.pid, start_time, time))                \r\n            completed += 1\r\n        else:\r\n            time += quantum\r\n            process.remaining_time -= quantum\r\n            results.append((process.pid, start_time, time))\r\n\r\n        while index < n and processes[index].arrival_time <= time:\r\n            if processes[index] not in ready_queue and processes[index].remaining_time > 0:\r\n                ready_queue.append(processes[index])\r\n                index += 1\r\n\r\n        if process.remaining_time > 0:\r\n            ready_queue.append(process)\r\n\r\n    performances = total_waiting_time / n\r\n    return results, time, performances\r\n\r\ndef rm_scheduling(processes): \r\n    time = 0\r\n    results = []\r\n    ready_queue = []\r\n    total_waiting_time = 0\r\n    start_time = 0\r\n    \r\n    hyperperiod = max([p.period for p in processes if p.period]) * 2  # simulation jusqu'à une certaine limite\r\n    processes.sort(key=lambda x: x.period)  # sort per period\r\n    temp_pid = processes[0].pid\r\n    temp_st_time = processes[0].arrival_time\r\n    temp_time = processes[0].arrival_time\r\n    temp_remaining_time = processes[0].remaining_time\r\n    # Initialize the ready queue with the process that arrive at time 0\r\n    for p in processes:\r\n            if (time - p.arrival_time) % p.period == 0 and time >= p.arrival_time:\r\n                new_instance = Process(p.pid, time, p.burst_time, p.period)\r\n                heapq.heappush(ready_queue, (new_instance.period, new_instance))\r\n    print(ready_queue)\r\n\r\n    print(\"debut traitement : \")\r\n    while time < hyperperiod:\r\n        # Ajouter les réapparitions périodiques\r\n        for p in processes:\r\n            if (time - p.period) % p.period == 0 and time > p.arrival_time:\r\n                new_instance = Process(p.pid, time, p.burst_time, p.period)\r\n                #print(\"time when the process is created\",time)\r\n                heapq.heappush(ready_queue, (new_instance.period, new_instance))\r\n        #print(ready_queue)\r\n        if ready_queue:\r\n            _, process = heapq.heappop(ready_queue)\r\n            if process.pid != temp_pid and temp_remaining_time > 0: # if the previous process is not the same as the current one we save it in the results\r\n                results.append((temp_pid, temp_st_time, temp_time))\r\n                start_time = 0\r\n            if start_time == 0:\r\n                start_time = time\r\n            time += 1\r\n            process.remaining_time -= 1\r\n            temp_remaining_time = process.remaining_time\r\n\r\n            if process.remaining_time == 0:\r\n                process.turnaround_time = time - process.arrival_time\r\n                process.waiting_time = process.turnaround_time - process.burst_time\r\n                total_waiting_time += process.waiting_time\r\n                results.append((process.pid, start_time, time))\r\n                start_time = 0\r\n            else:\r\n                temp_pid = process.pid\r\n                temp_st_time = start_time\r\n                temp_time = time\r\n                heapq.heappush(ready_queue, (process.period, process))\r\n        else:\r\n            time += 1\r\n\r\n    performances = total_waiting_time / len(processes)\r\n    return results, time, performances\r\n\r\ndef edf_scheduling(processes):\r\n    time = 0\r\n    results = []\r\n    ready_queue = []  # Renommé pour plus de clarté\r\n    total_waiting_time = 0\r\n    completed = 0\r\n    n = len(processes)\r\n\r\n    processes.sort(key=lambda x: x.arrival_time)\r\n    index = 0\r\n\r\n    while completed != n:\r\n        while index < n and processes[index].arrival_time <= time:\r\n            heapq.heappush(ready_queue, (processes[index].deadline, processes[index]))\r\n            index += 1\r\n\r\n        if not ready_queue:\r\n            time += 1\r\n            continue\r\n\r\n        _, process = heapq.heappop(ready_queue)\r\n\r\n        time += process.remaining_time\r\n        process.remaining_time = 0\r\n        process.waiting_time = time - process.arrival_time - process.burst_time \r\n        process.turnaround_time = time - process.arrival_time\r\n        total_waiting_time += process.waiting_time\r\n        results.append((process.pid, time - process.burst_time, time))\r\n        completed += 1\r\n\r\n        for p in processes:\r\n            if p.pid == process.pid:\r\n                p.arrival_time = time\r\n                p.deadline = time + p.period\r\n                p.remaining_time = p.burst_time\r\n                if p.arrival_time <= time:\r\n                    heapq.heappush(ready_queue, (p.deadline, p))\r\n                break\r\n\r\n    performances = total_waiting_time / n\r\n    return results, performances\r\n\r\nif __name__ == \"__main__\":\r\n    # test exemple\r\n    processes = [\r\n        Process(1, 0, 5),\r\n        Process(2, 1, 3),\r\n        Process(3, 2, 8),\r\n    ]\r\n    print(\"FCFS Scheduling:\")\r\n    fcfs_results, time, fcfs_avg_wait = fcfs_scheduling(processes)\r\n    print(fcfs_results)\r\n    print(\"Average Waiting Time:\", fcfs_avg_wait)\r\n\r\n    print(\"\\nSJN Scheduling:\")\r\n    sjn_results,time, sjn_avg_wait = sjn_scheduling(processes)\r\n    print(sjn_results)\r\n    print(\"Average Waiting Time:\", sjn_avg_wait)\r\n\r\n    print(\"\\nRR Scheduling:\")\r\n    rr_results, time, rr_avg_wait = rr_scheduling(processes)\r\n    print(rr_results)\r\n    print(\"Average Waiting Time:\", rr_avg_wait)\r\n    \r\n    processes1 = [\r\n        Process(1, 0, 1, 4),\r\n        Process(2, 0, 2, 5),  \r\n        Process(3, 0, 3, 10),  \r\n    ]\r\n    print(\"\\nRM Scheduling:\")\r\n    rm_results, rm_tt_time, rm_avg_wait = rm_scheduling(processes1)\r\n    print(rm_results)\r\n    print(\"Time:\", rm_tt_time)\r\n    print(\"Average Waiting Time:\", rm_avg_wait)\r\n\r\n    processes2 = [\r\n        Process(1, 0, 3, 10, 10),\r\n        Process(2, 2, 4, 15, 15), # Process 2 arrive plus tard\r\n        Process(3, 4, 5, 20, 20), # process 3 arrive encore plus tard\r\n    ]\r\n    print(\"\\nEDF Scheduling:\")\r\n    edf_results, edf_avg_wait = edf_scheduling(processes2)\r\n    print(edf_results)\r\n    print(\"Average Waiting Time:\", edf_avg_wait)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/process.py b/process.py
--- a/process.py	(revision 916aebf79a095ea150cf7d84dad995761c10d345)
+++ b/process.py	(date 1744817410479)
@@ -13,6 +13,7 @@
         self.deadline = deadline
 
 def fcfs_scheduling(processes):
+    print(processes)
     processes.sort(key=lambda x: x.arrival_time)  # sort per arrival
     time = 0
     results = []
Index: game_component.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport time as t\r\nimport random as rd\r\n\r\n\r\nclass Button:\r\n    \"\"\"\r\n    Button class provides functionality for creating interactive buttons in a Pygame application. It supports rendering buttons with customized styles, handling mouse events, and performing actions.\r\n\r\n    Methods:\r\n        - __init__(self, x, y, size_x, size_y, color, hover_color, text, font, text_color, text_color_hover, action=None): Initializes the button with position, size, color, text, font, and an optional action.\r\n        - draw(self, screen): Renders the button on the given Pygame screen. Changes appearance when hovered.\r\n        - handle_event(self, event): Handles mouse events to set hover state and execute the action when clicked.\r\n        - set_action(self, action): Assigns an action to be executed when the button is clicked.\r\n        - get_rect(self): Returns the rectangular area of the button for collision detection.\r\n        - set_text(self, new_text): Updates the button's text and adjusts its appearance accordingly.\r\n        - set_hover_color(self, hover_color): Updates the button's hover color.\r\n        - set_text_color(self, text_color): Updates the button's text color.\r\n        - set_text_color_hover(self, text_color_hover): Updates the button's text hover color.\r\n        - set_font(self, font): Updates the button's font and recalculates text rendering.\r\n    \"\"\"\r\n\r\n    def __init__(self, x, y, size_x, size_y, color, hover_color, text, font, text_color, text_color_hover, action=None):\r\n        self.rect = pygame.Rect(x, y, size_x, size_y)\r\n        self.color = color\r\n        self.hover_color = hover_color\r\n        self.text = text\r\n        self.font = font\r\n        self.text_color = text_color\r\n        self.text_color_hover = text_color_hover\r\n        self.action = action\r\n        self.hover = False\r\n        self.text_surface = self.font.render(self.text, True, self.text_color)\r\n        self.text_rect = self.text_surface.get_rect(center=self.rect.center)\r\n\r\n    def draw(self, screen):\r\n        if self.hover:\r\n            pygame.draw.rect(screen, self.hover_color, self.rect)\r\n            pygame.draw.rect(screen, self.text_color_hover, self.text_rect)\r\n        else:\r\n            pygame.draw.rect(screen, self.color, self.rect)\r\n            pygame.draw.rect(screen, self.text_color, self.text_rect)\r\n        screen.blit(self.text_surface, self.text_rect)\r\n\r\n    def handle_event(self, event):\r\n        if event.type == pygame.MOUSEBUTTONDOWN:\r\n            if self.rect.collidepoint(event.pos):\r\n                self.hover = True\r\n            else:\r\n                self.hover = False\r\n        if event.type == pygame.MOUSEBUTTONUP and event.button == 1:\r\n            if self.rect.collidepoint(event.pos) and self.action:\r\n                self.action()\r\n\r\n    def set_action(self, action):\r\n        self.action = action\r\n\r\n    def get_rect(self):\r\n        return self.rect\r\n\r\n    def set_text(self, new_text):\r\n        self.text = new_text\r\n        self.text_surface = self.font.render(new_text, True, self.text_color)\r\n        self.text_rect = self.text_surface.get_rect(center=self.rect.center)\r\n        print(\"Done\")\r\n\r\n    def set_hover_color(self, hover_color):\r\n        self.hover_color = hover_color\r\n        print(\"Done\")\r\n\r\n    def set_text_color(self, text_color):\r\n        self.text_color = text_color\r\n        self.text_surface = self.font.render(text_color, True, self.text_color)\r\n        self.text_rect = self.text_surface.get_rect(center=self.rect.center)\r\n        print(\"Done\")\r\n\r\n    def set_text_color_hover(self, text_color_hover):\r\n        self.text_color_hover = text_color_hover\r\n        self.text_surface = self.font.render(text_color_hover, True, self.text_color)\r\n        self.text_rect = self.text_surface.get_rect(center=self.rect.center)\r\n        print(\"Done\")\r\n\r\n    def set_font(self, font):\r\n        self.font = font\r\n        self.text_surface = self.font.render(self.text, True, self.text_color)\r\n        self.text_rect = self.text_surface.get_rect(center=self.rect.center)\r\n        print(\"Done\")\r\n\r\n\r\nclass Chronometer:\r\n    \"\"\"\r\n        A Chronometer class for measuring elapsed time and displaying it on a graphical interface.\r\n\r\n        Methods:\r\n            __init__(self, x, y, size, font, couleur=(255, 255, 255)):\r\n                Initializes a Chronometer instance with specified position, size, font, and color.\r\n\r\n            start(self):\r\n                Starts the chronometer by recording the current time.\r\n\r\n            stop(self):\r\n                Stops the chronometer by recording the current time. Raises an error if the chronometer has not been started.\r\n\r\n            time_up(self):\r\n                Calculates the elapsed time since the chronometer was started. Returns the current elapsed time, or if stopped, the total elapsed time. Raises an error if the chronometer has not been started.\r\n\r\n            reset(self):\r\n                Resets the chronometer by clearing the start and stop times.\r\n\r\n            draw(self, screen):\r\n                Draws the current elapsed time on the specified screen using the provided font and color, starting from the initial position defined during initialization.\r\n    \"\"\"\r\n\r\n    def __init__(self, x, y, size, font, couleur=(255, 255, 255)):\r\n        self._debut = None\r\n        self._fin = None\r\n        self.x = x\r\n        self.y = y\r\n        self.font = font\r\n        self.couleur = couleur\r\n        self.size = size\r\n\r\n    def start(self):\r\n        self._debut = t.time()\r\n\r\n    def stop(self):\r\n        if self._debut is None:\r\n            raise ValueError(\"Chronometer has not been started\")\r\n        self._fin = t.time()\r\n\r\n    def time_up(self):\r\n        if self._debut is None:\r\n            raise ValueError(\"Chronometer has not been started\")\r\n        if self._fin is None:\r\n            return t.time() - self._debut\r\n        return self._fin - self._debut\r\n\r\n    def reset(self):\r\n        self._debut = None\r\n        self._fin = None\r\n\r\n    def draw(self, screen):\r\n        if self._debut is None:\r\n            text = \"0.00\"\r\n        else:\r\n            text = f\"{self.time_up():.2f}\"\r\n        text_surface = self.font.render(text, True, self.couleur)\r\n        text_rect = text_surface.get_rect(topleft=(self.x, self.y))\r\n        screen.blit(text_surface, text_rect)\r\n\r\n\r\nclass Score:\r\n    \"\"\"\r\n        Class representing a Score system to manage and display scores.\r\n\r\n        Methods:\r\n            __init__(x, y, font, couleur=(255, 255, 255)):\r\n                Initializes the score system with position, font, color, and initializes score to 0.\r\n\r\n            add_score(score):\r\n                Adds a specified score to the current score.\r\n\r\n            subtract_score(score):\r\n                Subtracts a specified score from the current score, ensuring the score does not go below zero.\r\n\r\n            set_score(score):\r\n                Updates the current score to a specified value.\r\n\r\n            get_score():\r\n                Retrieves the current score value.\r\n\r\n            reset():\r\n                Resets the score to zero.\r\n\r\n            draw(screen):\r\n                Draws the current score as text onto the specified screen using the given font and color.\r\n    \"\"\"\r\n\r\n    def __init__(self, x, y, font, couleur=(255, 255, 255)):\r\n        self.x = x\r\n        self.y = y\r\n        self.font = font\r\n        self.couleur = couleur\r\n        self.score = 0\r\n\r\n    def add_score(self, score):\r\n        self.score += score\r\n\r\n    def subtract_score(self, score):\r\n        self.score -= score\r\n        if self.score < 0:\r\n            self.score = 0\r\n\r\n    def set_score(self, score):\r\n        self.score = score\r\n\r\n    def get_score(self):\r\n        return self.score\r\n\r\n    def reset(self):\r\n        self.score = 0\r\n\r\n    def draw(self, screen):\r\n        text = f\"{self.score:.2f}\"\r\n        text_surface = self.font.render(text, True, self.couleur)\r\n        text_rect = text_surface.get_rect(topleft=(self.x, self.y))\r\n        screen.blit(text_surface, text_rect)\r\n\r\n\r\nclass Thread:\r\n    \"\"\"\r\n    Thread class representing a level-based thread generation system, with adjustable difficulty and graphical representation capabilities.\r\n\r\n    Attributes:\r\n        x (int): Horizontal position for thread rendering.\r\n        y (int): Vertical position for thread rendering.\r\n        size (int): Font size used for rendering the threads.\r\n        font (Font): Font object used for text rendering.\r\n        couleur (tuple): RGB tuple representing the color of rendered text.\r\n        thread (list): A list of generated process dictionaries.\r\n        min_thread (int): Minimum number of threads in a level.\r\n        max_thread (int): Maximum number of threads in a level.\r\n        min_arrival_time (int): Minimum arrival time for process generation.\r\n        max_arrival_time (int): Maximum arrival time for process generation.\r\n        min_burst_time (int): Minimum burst time for process generation.\r\n        max_burst_time (int): Maximum burst time for process generation.\r\n        min_period (int): Minimum period for process generation.\r\n        max_period (int): Maximum period for process generation.\r\n        difficulty (int): Current difficulty level of the thread generation system.\r\n\r\n    Methods:\r\n        create_thread():\r\n            Generates a list of processes with random properties based on defined constraints.\r\n\r\n        adjust_to_difficulty():\r\n            Adjusts thread generation constraints such as number and arrival time based on the current difficulty level.\r\n\r\n        set_difficulty(difficulty):\r\n            Sets the difficulty level for thread generation.\r\n\r\n        get_difficulty():\r\n            Returns the current difficulty level.\r\n\r\n        reset():\r\n            Resets the generated thread list to an empty state.\r\n\r\n        create_level():\r\n            Adjusts constraints based on difficulty and generates a new list of threads. Returns the updated thread list.\r\n\r\n        draw(screen):\r\n            Renders the list of threads on the specified screen surface, with each thread displayed as a formatted text with specified font and color.\r\n    \"\"\"\r\n\r\n    def __init__(self, x, y, size, font, couleur=(255, 255, 255)):\r\n        self.x = x\r\n        self.y = y\r\n        self.size = size\r\n        self.font = font\r\n        self.couleur = couleur\r\n        self.thread = []\r\n        self.min_thread = 3\r\n        self.max_thread = 20\r\n        self.min_arrival_time = 0\r\n        self.max_arrival_time = 30\r\n        self.min_burst_time = 1\r\n        self.max_burst_time = 15\r\n        self.min_period = 0\r\n        self.max_period = 15\r\n        self.difficulty = 1\r\n\r\n    def create_thread(self):\r\n        number_of_process = rd.randint(self.min_thread, self.max_thread)\r\n        for i in range(number_of_process):\r\n            burst_time = rd.randint(self.min_burst_time, self.max_burst_time)\r\n            process = dict(name=\"L\" + str(i), arrival_time=rd.randint(self.min_arrival_time, self.max_arrival_time),\r\n                           burst_time=burst_time,\r\n                           period=rd.randint(self.min_period, self.max_period),\r\n                           deadline=2*burst_time )\r\n            self.thread.append(process)\r\n\r\n    def adjust_to_difficulty(self):\r\n        if self.difficulty == 1:\r\n            self.min_thread = 3\r\n            self.max_thread = 5\r\n            self.max_arrival_time = 5\r\n            self.max_period = 0\r\n        elif self.difficulty == 2:\r\n            self.min_thread = 5\r\n            self.max_thread = 10\r\n            self.max_arrival_time = 10\r\n            self.max_period = 0\r\n        elif self.difficulty == 3:\r\n            self.min_thread = 10\r\n            self.max_thread = 15\r\n            self.max_arrival_time = 20\r\n            self.max_period = 5\r\n        elif self.difficulty == 4:\r\n            self.min_thread = 15\r\n            self.max_thread = 20\r\n            self.max_arrival_time = 30\r\n            self.max_period = 15\r\n\r\n    def set_difficulty(self, difficulty):\r\n        self.difficulty = difficulty\r\n\r\n    def get_difficulty(self):\r\n        return self.difficulty\r\n\r\n    def reset(self):\r\n        self.thread = []\r\n\r\n    def create_level(self):\r\n        self.adjust_to_difficulty()\r\n        self.create_thread()\r\n        return self.thread\r\n\r\n    def draw(self, screen):\r\n        header_color = (68,114,196,255)\r\n        row_color = (207,213,234,255)\r\n        # Dessiner l'en-tête du tableau\r\n        header_labels = [\"Name\", \"Arrival time\", \"Burst time\", \"Period\",\"Deadline\"]\r\n        x_offset = self.x\r\n        padding = 10\r\n        column_widths = [50, 80, 80, 50,80]\r\n        header_height = self.size + 10\r\n\r\n        # Dessiner le rectangle de l'en-tête\r\n        pygame.draw.rect(screen, header_color, (self.x, self.y, sum(column_widths) + padding * (len(header_labels) - 1), header_height))\r\n\r\n        # Afficher le texte de l'en-tête\r\n        header_text_color = (0, 0, 0)  # Couleur du texte de l'en-tête\r\n        for i, label in enumerate(header_labels):\r\n            text_surface = self.font.render(label, True, header_text_color)\r\n            text_rect = text_surface.get_rect(topleft=(x_offset + padding // 2, self.y + (header_height - text_surface.get_height()) // 2))\r\n            screen.blit(text_surface, text_rect)\r\n            x_offset += column_widths[i] + padding\r\n\r\n        # Dessiner les données des processus\r\n        y_offset = self.y + header_height + 5\r\n        for i, process in enumerate(self.thread):\r\n            x_offset = self.x\r\n            data = [process['name'], str(process['arrival_time']), str(process['burst_time']),str(process['period']),str(process['deadline'])]\r\n\r\n            # Dessiner le fond de la ligne\r\n            row_rect = pygame.Rect(self.x, y_offset - 2, sum(column_widths) + padding * (len(header_labels) - 1), self.size + 4)\r\n            pygame.draw.rect(screen, row_color, row_rect)\r\n\r\n            for j, value in enumerate(data):\r\n                text_surface = self.font.render(value, True, self.couleur)\r\n                text_rect = text_surface.get_rect(topleft=(x_offset + padding // 2, y_offset + (self.size - text_surface.get_height()) // 2))\r\n                screen.blit(text_surface, text_rect)\r\n                x_offset += column_widths[j] + padding\r\n            y_offset += self.size + 5\r\n\r\n\r\nclass Block:\r\n    \"\"\"\r\n    Block class represents a graphical object that displays an image and accompanying text.\r\n\r\n    Attributes:\r\n        original_image: Original image loaded from the specified file path.\r\n        size: Tuple representing the dimensions (width, height) of the block.\r\n        image: Scaled version of the original image based on the specified size.\r\n        rect: Rectangle representation of the block for positioning and collision purposes.\r\n        text: String text displayed on the block.\r\n        font: Pygame font object used for rendering text.\r\n        text_color: Tuple representing RGB values of the text color.\r\n        combined_image: Image object combining the block's scaled image and rendered text.\r\n\r\n    Methods:\r\n        render_text:\r\n            Renders the associated text onto the image at the center of the block.\r\n\r\n        update_text:\r\n            Updates the text displayed on the block and re-renders it.\r\n\r\n        update_size:\r\n            Updates the block's size, rescales the image, and adjusts its position.\r\n\r\n        draw:\r\n            Draws the block's combined image (image and text) onto a Pygame surface.\r\n    \"\"\"\r\n\r\n    def __init__(self, x, y, size, font, text, image_path, text_color=(255, 255, 255)):\r\n        self.original_image = pygame.image.load(image_path).convert_alpha()\r\n        self.size = size\r\n        self.image = pygame.transform.scale(self.original_image, size)\r\n        self.rect = self.image.get_rect(topleft=(x, y))\r\n        self.text = text\r\n        self.font = font\r\n        self.text_color = text_color\r\n        self.render_text()\r\n\r\n    def render_text(self):\r\n        text_surface = self.font.render(self.text, True, self.text_color)\r\n        text_rect = text_surface.get_rect(center=self.rect.center)\r\n        self.combined_image = self.image.copy()\r\n        self.combined_image.blit(text_surface, text_rect)\r\n\r\n    def update_text(self, text):\r\n        self.text = text\r\n        self.render_text()\r\n\r\n    def update_size(self, size):\r\n        self.size = size\r\n        self.image = pygame.transform.scale(self.original_image, size)\r\n        self.rect = self.image.get_rect(topleft=self.rect.topleft)\r\n        self.render_text()\r\n\r\n    def draw(self, screen):\r\n        screen.blit(self.combined_image, self.rect)\r\n\r\nclass Image:\r\n    def __init__(self,filephath,x,y,size_x,size_y,alpha=None):\r\n        self.filepath = filephath\r\n        self.x = x\r\n        self.y = y\r\n        self.size_x = size_x\r\n        self.size_y = size_y\r\n        self.alpha = alpha\r\n        self.image = self._load_image()\r\n        self.rect = self.image.get_rect(topleft=(x,y))\r\n\r\n    def _load_image(self):\r\n        try:\r\n            if self.alpha:\r\n                image = pygame.image.load(self.filepath).convert_alpha()\r\n            else:\r\n                image = pygame.image.load(self.filepath).convert()\r\n        except pygame.error as e:\r\n            print(f\"Erreur lors du chargement de l'image : {self.filepath}\")\r\n            print(f\"Erreur Pygame : {e}\")\r\n            # Retourne une surface noire de 1x1 pour éviter les erreurs.\r\n            return pygame.Surface((1, 1))\r\n\r\n        if self.size_x is not None and self.size_y is not None:\r\n            try:\r\n                image = pygame.transform.scale(image, (self.size_x, self.size_y))\r\n            except TypeError:\r\n                print(\r\n                    f\"Erreur : Les arguments 'size_x' et 'size_y' doivent être des entiers. Image : {self.filepath}\")\r\n                # Retourne l'image originale\r\n                return image\r\n            except ValueError:\r\n                print(\r\n                    f\"Erreur : Les arguments 'size_x' et 'size_y' doivent être positifs. Image: {self.filepath}\")\r\n                return image\r\n        return image\r\n\r\n    def draw(self, surface, position=None):  # position est maintenant optionnel\r\n        if position is None:\r\n            self.rect.topleft = (self.x, self.y)  # Utilise la position de l'objet\r\n        else:\r\n            self.rect.topleft = position  # Utilise la position donnée\r\n        surface.blit(self.image, self.rect)\r\n\r\n    def get_width(self):\r\n        return self.image.get_width()\r\n\r\n    def get_height(self):\r\n        return self.image.get_height()\r\n\r\n    def get_size(self):\r\n        return self.image.get_size()\r\n\r\n    def get_rect(self):\r\n        \"\"\"\r\n        Retourne le rectangle (pygame.Rect) de l'image.  Utile pour la collision\r\n        et le positionnement.\r\n        \"\"\"\r\n        return self.rect\r\n\r\n    def copy(self):\r\n        \"\"\"\r\n        Retourne une copie de l'objet PygameImage.\r\n        \"\"\"\r\n        new_image = Image(self.filepath, self.x, self.y, self.size_x, self.size_y, self.alpha)\r\n        new_image.rect = self.rect.copy()\r\n        return new_image\r\n\r\n    def fill(self, color):\r\n        \"\"\"\r\n        Remplit l'image avec une couleur spécifiée.\r\n        \"\"\"\r\n        self.image.fill(color)\r\n\r\n    def rotate(self, angle):\r\n        \"\"\"\r\n        Rotate the image by the specified angle in degrees.\r\n        \"\"\"\r\n        self.image = pygame.transform.rotate(self.image, angle)\r\n        self.rect = self.image.get_rect(center=self.rect.center)  # Keep center.\r\n\r\n    def scale_image(self, scale):\r\n        \"\"\"\r\n        Scales the image\r\n        \"\"\"\r\n        self.image = pygame.transform.scale(self.image, scale)\r\n        self.rect = self.image.get_rect(center=self.rect.center)\r\n\r\n    def get_image(self):\r\n        \"\"\"\r\n        Returns the pygame image\r\n        \"\"\"\r\n        return self.image\r\n\r\n\r\npygame.font.init()\r\nfont = pygame.font.SysFont(\"Arial\", 20)\r\n(width, height) = (1200, 800)\r\nscreen = pygame.display.set_mode((width, height))\r\nt1 = Thread(0, 0, 20, font,(0,0,0))\r\nt1.set_difficulty(1)\r\nt2 = t1.create_level()\r\nt1.draw(screen)\r\nrunning = True\r\nprint(t2)\r\nwhile running:\r\n    for event in pygame.event.get():\r\n        if event.type == pygame.QUIT:\r\n            running = False\r\n\r\n    screen.fill((0,0,0))\r\n    t1.draw(screen)\r\n    pygame.display.flip()\r\n\r\npygame.quit()\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game_component.py b/game_component.py
--- a/game_component.py	(revision 916aebf79a095ea150cf7d84dad995761c10d345)
+++ b/game_component.py	(date 1744817375151)
@@ -1,6 +1,8 @@
 import pygame
 import time as t
 import random as rd
+import process as pro
+from process import Process
 
 
 class Button:
@@ -272,7 +274,8 @@
         number_of_process = rd.randint(self.min_thread, self.max_thread)
         for i in range(number_of_process):
             burst_time = rd.randint(self.min_burst_time, self.max_burst_time)
-            process = dict(name="L" + str(i), arrival_time=rd.randint(self.min_arrival_time, self.max_arrival_time),
+            process = dict(name="L" + str(i),
+                           arrival_time=rd.randint(self.min_arrival_time, self.max_arrival_time),
                            burst_time=burst_time,
                            period=rd.randint(self.min_period, self.max_period),
                            deadline=2*burst_time )
@@ -314,6 +317,13 @@
         self.create_thread()
         return self.thread
 
+    def get_thread(self):
+        thread_dict = self.thread
+        thread_list = []
+        for i in thread_dict:
+            thread_list.append(Process(i['arrival_time'],i['burst_time'],i['period'],i['deadline']))
+        return thread_list
+
     def draw(self, screen):
         header_color = (68,114,196,255)
         row_color = (207,213,234,255)
@@ -504,7 +514,6 @@
         """
         return self.image
 
-
 pygame.font.init()
 font = pygame.font.SysFont("Arial", 20)
 (width, height) = (1200, 800)
@@ -514,14 +523,18 @@
 t2 = t1.create_level()
 t1.draw(screen)
 running = True
-print(t2)
+cpu = Image("element/cpu.png",screen.get_width()/2,screen.get_height()/2,100,100)
+print(t1.get_thread())
+result,time,performances = pro.fcfs_scheduling(t1.get_thread())
+print(result)
 while running:
     for event in pygame.event.get():
         if event.type == pygame.QUIT:
             running = False
 
-    screen.fill((0,0,0))
+    screen.fill((255,255,255))
     t1.draw(screen)
+    cpu.draw(screen)
     pygame.display.flip()
 
 pygame.quit()
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"618f0c16-c5e1-48b9-ae1e-509c403f88f5\" name=\"Changes\" comment=\"modified game_component.py\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_26_03_2025_09_57_[Changes]/img.png\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_26_03_2025_09_57_[Changes]/shelved.patch\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_26_03_2025_09_57__Changes_.xml\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_26_03_2025_11_38_[Changes]/shelved.patch\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_26_03_2025_11_38__Changes_.xml\" beforeDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/game_component.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/game_component.py\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Python Script\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;NFXSTUDIO&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">{\r\n  &quot;selectedUrlAndAccountId&quot;: {\r\n    &quot;url&quot;: &quot;https://github.com/NFXSTUDIO/Systeme_temp_reel&quot;,\r\n    &quot;accountId&quot;: &quot;2cbd9472-19ec-438a-8c4a-a6caa5f58057&quot;\r\n  }\r\n}</component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 1\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2uqSjJcl5xrENyG6gXVpSGgKxFi\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\"><![CDATA[{\r\n  \"keyToString\": {\r\n    \"Python.game_component.executor\": \"Run\",\r\n    \"Python.test.executor\": \"Run\",\r\n    \"RunOnceActivity.ShowReadmeOnStart\": \"true\",\r\n    \"git-widget-placeholder\": \"master\",\r\n    \"last_opened_file_path\": \"C:/Users/arthu/Desktop/ARTHUR T/ECOLE/IPSA/AERO4/IN423-Réseaux embarqué/LAB 4 RESEAU/client_final.py\",\r\n    \"node.js.detected.package.eslint\": \"true\",\r\n    \"node.js.detected.package.tslint\": \"true\",\r\n    \"node.js.selected.package.eslint\": \"(autodetect)\",\r\n    \"node.js.selected.package.tslint\": \"(autodetect)\",\r\n    \"nodejs_package_manager_path\": \"npm\",\r\n    \"settings.editor.selected.configurable\": \"preferences.pluginManager\",\r\n    \"vue.rearranger.settings.migration\": \"true\"\r\n  }\r\n}]]></component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-js-predefined-d6986cc7102b-7c0b70fcd90d-JavaScript-PY-242.21829.153\" />\r\n        <option value=\"bundled-python-sdk-464836ebc622-b74155a9e76b-com.jetbrains.pycharm.pro.sharedIndexes.bundled-PY-242.21829.153\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"618f0c16-c5e1-48b9-ae1e-509c403f88f5\" name=\"Changes\" comment=\"\" />\r\n      <created>1742974744646</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1742974744646</updated>\r\n      <workItem from=\"1742974746532\" duration=\"12116000\" />\r\n      <workItem from=\"1742987186098\" duration=\"864000\" />\r\n      <workItem from=\"1743571205855\" duration=\"17000\" />\r\n      <workItem from=\"1743584524920\" duration=\"1497000\" />\r\n      <workItem from=\"1743665306963\" duration=\"640000\" />\r\n      <workItem from=\"1744803604696\" duration=\"5352000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"main\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742974827674</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742974827675</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"main\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742974924124</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742974924124</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"add pygame\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742975750269</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742975750269</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"add block.py\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742978023112</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742978023112</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"test and integration\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742979465237</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742979465237</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"add game_component.py\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742985542882</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742985542882</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"modified game_component.py\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742986554479</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742986554479</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"8\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"main\" />\r\n    <MESSAGE value=\"add pygame\" />\r\n    <MESSAGE value=\"add block.py\" />\r\n    <MESSAGE value=\"test and integration\" />\r\n    <MESSAGE value=\"add game_component.py\" />\r\n    <MESSAGE value=\"modified game_component.py\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"modified game_component.py\" />\r\n  </component>\r\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\r\n    <SUITE FILE_PATH=\"coverage/Systeme_temp_real$game_component.coverage\" NAME=\"game_component Coverage Results\" MODIFIED=\"1744807322256\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/Systeme_temp_real$test.coverage\" NAME=\"test Coverage Results\" MODIFIED=\"1742979397549\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision 916aebf79a095ea150cf7d84dad995761c10d345)
+++ b/.idea/workspace.xml	(date 1744873838977)
@@ -5,13 +5,10 @@
   </component>
   <component name="ChangeListManager">
     <list default="true" id="618f0c16-c5e1-48b9-ae1e-509c403f88f5" name="Changes" comment="modified game_component.py">
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_26_03_2025_09_57_[Changes]/img.png" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_26_03_2025_09_57_[Changes]/shelved.patch" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_26_03_2025_09_57__Changes_.xml" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_26_03_2025_11_38_[Changes]/shelved.patch" beforeDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/shelf/Uncommitted_changes_before_Update_at_26_03_2025_11_38__Changes_.xml" beforeDir="false" />
+      <change afterPath="$PROJECT_DIR$/element/cpu.png" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/game_component.py" beforeDir="false" afterPath="$PROJECT_DIR$/game_component.py" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/process.py" beforeDir="false" afterPath="$PROJECT_DIR$/process.py" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -49,22 +46,30 @@
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent"><![CDATA[{
-  "keyToString": {
-    "Python.game_component.executor": "Run",
-    "Python.test.executor": "Run",
-    "RunOnceActivity.ShowReadmeOnStart": "true",
-    "git-widget-placeholder": "master",
-    "last_opened_file_path": "C:/Users/arthu/Desktop/ARTHUR T/ECOLE/IPSA/AERO4/IN423-Réseaux embarqué/LAB 4 RESEAU/client_final.py",
-    "node.js.detected.package.eslint": "true",
-    "node.js.detected.package.tslint": "true",
-    "node.js.selected.package.eslint": "(autodetect)",
-    "node.js.selected.package.tslint": "(autodetect)",
-    "nodejs_package_manager_path": "npm",
-    "settings.editor.selected.configurable": "preferences.pluginManager",
-    "vue.rearranger.settings.migration": "true"
-  }
-}]]></component>
+  <component name="PropertiesComponent">{
+  &quot;keyToString&quot;: {
+    &quot;Python.game_component.executor&quot;: &quot;Run&quot;,
+    &quot;Python.test.executor&quot;: &quot;Run&quot;,
+    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
+    &quot;git-widget-placeholder&quot;: &quot;master&quot;,
+    &quot;last_opened_file_path&quot;: &quot;C:/Users/arthu/PycharmProjects/Systeme_temp_real&quot;,
+    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
+    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
+    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
+    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
+    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
+    &quot;settings.editor.selected.configurable&quot;: &quot;preferences.pluginManager&quot;,
+    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
+  }
+}</component>
+  <component name="RecentsManager">
+    <key name="CopyFile.RECENT_KEYS">
+      <recent name="C:\Users\arthu\PycharmProjects\Systeme_temp_real" />
+    </key>
+    <key name="MoveFile.RECENT_KEYS">
+      <recent name="C:\Users\arthu\PycharmProjects\Systeme_temp_real\element" />
+    </key>
+  </component>
   <component name="SharedIndexes">
     <attachedChunks>
       <set>
@@ -86,7 +91,7 @@
       <workItem from="1743571205855" duration="17000" />
       <workItem from="1743584524920" duration="1497000" />
       <workItem from="1743665306963" duration="640000" />
-      <workItem from="1744803604696" duration="5352000" />
+      <workItem from="1744803604696" duration="11035000" />
     </task>
     <task id="LOCAL-00001" summary="main">
       <option name="closed" value="true" />
@@ -144,7 +149,15 @@
       <option name="project" value="LOCAL" />
       <updated>1742986554479</updated>
     </task>
-    <option name="localTasksCounter" value="8" />
+    <task id="LOCAL-00008" summary="modified game_component.py">
+      <option name="closed" value="true" />
+      <created>1744809024626</created>
+      <option name="number" value="00008" />
+      <option name="presentableId" value="LOCAL-00008" />
+      <option name="project" value="LOCAL" />
+      <updated>1744809024626</updated>
+    </task>
+    <option name="localTasksCounter" value="9" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -171,7 +184,7 @@
     <option name="LAST_COMMIT_MESSAGE" value="modified game_component.py" />
   </component>
   <component name="com.intellij.coverage.CoverageDataManagerImpl">
-    <SUITE FILE_PATH="coverage/Systeme_temp_real$game_component.coverage" NAME="game_component Coverage Results" MODIFIED="1744807322256" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/Systeme_temp_real$game_component.coverage" NAME="game_component Coverage Results" MODIFIED="1744817410490" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/Systeme_temp_real$test.coverage" NAME="test Coverage Results" MODIFIED="1742979397549" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
   </component>
 </project>
\ No newline at end of file
